
struct_integral* FullSimpsonFormula(double a, double b, double eps)
{
	vector<double> err;
	vector<int>number_nodes;
	vector<double> integral;
	struct_integral_t* integr = new struct_integral_t[1];
	integr->err = err;
	integr->number_nodes = number_nodes;
	integr->integral = integral;
	int counter = 0;
	double I = CavalieriSimpsonFormula(a, b, eps);
	double I_prev = CavalieriSimpsonFormula(a, b, eps);
	counter++;
	integral.push_back(I);
	err.push_back((abs(I - I_prev) / (2 * N - 1)));
	while ((abs(I - I_prev) / (2 *N - 1)) > eps)
	{
		err.push_back((abs(I - I_prev) / (2 * N - 1)));
		I_prev = I;
		counter++;
		I = CavalieriSimpsonFormula(a, b, eps);
		integral.push_back(I);
		number_nodes.push_back(counter);
	}
	//return number_nodes;
	return integr;
}

double CavalieriSimpsonFormula(double a, double b, double eps)
{
	double I_prev = eps + 1, I_cur = 0;//I_prev-предыдущее вычисленное значение интеграла, I_cur-новое, с большим N.
	for (int n = 1; (n <= N) || (fabs(I_cur - I_prev) > eps); n *= 2)
	{
		double h, sum2 = 0, sum4 = 0, sum = 0;
		h = (b - a) / (2 * n);//Шаг интегрирования.
		for (int i = 1; i <= 2 * n - 1; i += 2)
		{
			sum4 += f(a + h * i);//Значения с нечётными индексами, которые нужно умножить на 4.
			sum2 += f(a + h * (i + 1));//Значения с чётными индексами, которые нужно умножить на 2.
		}
		sum = f(a) + 4 * sum4 + 2 * sum2 - f(b);//Отнимаем значение f(b) так как ранее прибавили его дважды. 
		I_prev = I_cur;
		I_cur = (h / 3) * sum;
	}
	return I_cur;
}
